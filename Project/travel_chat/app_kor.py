# import library
import asyncio

loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)
import streamlit as st
import pandas as pd
import json
import requests
import os
from dotenv import load_dotenv
from pydantic import BaseModel, Field
import folium
from streamlit_folium import folium_static

import chatbot_core
import route_core
from firebase_admin import auth
import auth_core
import data_core

from langchain.chat_models import ChatOpenAI
from langchain.embeddings import HuggingFaceEmbeddings
from langchain.text_splitter import CharacterTextSplitter
from langchain.vectorstores import FAISS
from langchain.document_loaders import DataFrameLoader
from langchain.agents import tool
import datetime

load_dotenv()

# Load environment variables from .env file

# Retrieve the API key from the environment variable
# api_key = os.getenv('API_KEY')
# openai_api_key = os.getenv("MY_OPENAI_KEY")
url = 'https://places.googleapis.com/v1/places:searchText'

st.set_page_config(page_title="travel assistant", layout="wide", page_icon="üõ´", menu_items={
        'About': "Ïù¥ appÏùÄ Ïó¨Îü¨Î∂ÑÎì§Ïùò Ïó¨ÌñâÏùÑ ÎèÑÏôÄÏ§Ñ Í±∞ÏóêÏöî!"
    })

# st.write(os.getcwd())
with st.sidebar:
    auth_core.main()


# if not api_key:
#     raise ValueError("API_KEY not found in environment variables. Please set it in the .env file.")
# if not openai_api_key:
#     raise ValueError("MY_OPENAI_KEY not found in environment variables. Please set it in the .env file.")

def get_current_temperature(latitude: float, longitude: float) -> dict:
    """Fetch current temperature for given coordinates."""

    BASE_URL = "https://api.open-meteo.com/v1/forecast"

    # Parameters for the request
    params = {
        'latitude': latitude,
        'longitude': longitude,
        'hourly': 'temperature_2m',
        'forecast_days': 1,
    }

    # Make the request
    response = requests.get(BASE_URL, params=params)

    if response.status_code == 200:
        results = response.json()
    else:
        raise Exception(f"API Request failed with status code: {response.status_code}")

    current_utc_time = datetime.datetime.utcnow()
    time_list = [datetime.datetime.fromisoformat(time_str.replace('Z', '+00:00')) for time_str in
                 results['hourly']['time']]
    temperature_list = results['hourly']['temperature_2m']

    closest_time_index = min(range(len(time_list)), key=lambda i: abs(time_list[i] - current_utc_time))
    current_temperature = temperature_list[closest_time_index]

    return current_temperature


def main():
    # st.sidebar.title("Travel Recommendation App Demo")
    # st.write(st.session_state)
    # if 'user_info' not in st.session_state:
    #     return
    if not st.session_state['authentication_status']:
        return
    # api_key = st.sidebar.text_input("Google Maps API keyÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî:", type="password")
    # os.environ["GOOGLE_MAP_API_KEY"] = api_key
    # openai_api_key = st.sidebar.text_input("OpenAI API keyÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî:", type="password")
    # os.environ["OPENAI_API_KEY"] = openai_api_key
    os.environ["GOOGLE_MAP_API_KEY"] = st.secrets["GOOGLE_MAP_API_KEY"]
    os.environ["OPENAI_API_KEY"] = st.secrets["OPENAI_API_KEY"]

    st.sidebar.write('ÏïÑÎûò ÎÇ¥Ïö©ÏùÑ Î™®Îëê Ï±ÑÏõåÏ£ºÏÑ∏Ïöî.')
    destination = st.sidebar.text_input('Ïñ¥Îäê ÏßÄÏó≠ÏúºÎ°ú Í∞ÄÏãúÎÇòÏöî?:', key='destination_app')
    min_rating = st.sidebar.number_input('ÏµúÏÜå Î≥ÑÏ†êÏùÄ ÏñºÎßàÎ°ú Ìï†ÍπåÏöî?:', value=4.0, min_value=0.5, max_value=4.5, step=0.5,
                                         key='minrating_app')
    radius = st.sidebar.number_input('Î™á ÎØ∏ÌÑ∞ Î∞òÍ≤ΩÏúºÎ°ú Ï∞æÏùÑÍπåÏöî?:', value=3000, min_value=500, max_value=50000, step=100,
                                     key='radius_app')

    if destination:
        headers = {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': os.environ["GOOGLE_MAP_API_KEY"],
            'X-Goog-FieldMask': 'places.location',
        }
        data = {
            'textQuery': destination,
            'maxResultCount': 1,
        }

        # Convert data to JSON format
        json_data = json.dumps(data)

        # Make the POST request
        response = requests.post(url, data=json_data, headers=headers)

        # Print the response
        result = response.json()

        print(result)

        # Convert JSON data to DataFrame
        df = pd.json_normalize(result['places'])

        # Get the latitude and longitude values
        initial_latitude = df['location.latitude'].iloc[0]
        initial_longitude = df['location.longitude'].iloc[0]

        # Create the circle
        circle_center = {"latitude": initial_latitude, "longitude": initial_longitude}
        circle_radius = radius

        headers_place = {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': os.environ["GOOGLE_MAP_API_KEY"],
            'X-Goog-FieldMask': 'places.displayName,places.formattedAddress,places.priceLevel,places.userRatingCount,places.rating,places.websiteUri,places.location,places.googleMapsUri',
        }

        def hotel():
            data_hotel = {
                'textQuery': f'Place to stay near {destination}',
                'minRating': min_rating,
                'languageCode': 'ko',
                'locationBias': {
                    "circle": {
                        "center": circle_center,
                        "radius": circle_radius
                    }
                }
            }

            # Convert data to JSON format
            json_data_hotel = json.dumps(data_hotel)
            # Make the POST request
            response_hotel = requests.post(url, data=json_data_hotel, headers=headers_place)
            # Print the response
            result_hotel = response_hotel.json()
            print(result_hotel)
            # Convert JSON data to DataFrame
            df_hotel = pd.json_normalize(result_hotel['places'])
            # Add 'type'
            df_hotel['type'] = 'Hotel'
            return df_hotel

        def restaurant():
            data_restaurant = {
                'textQuery': f'Place to eat near {destination}',
                'minRating': min_rating,
                'languageCode': 'ko',
                'locationBias': {
                    "circle": {
                        "center": circle_center,
                        "radius": circle_radius
                    }
                }
            }

            # Convert data to JSON format
            json_data_restaurant = json.dumps(data_restaurant)
            # Make the POST request
            response_restaurant = requests.post(url, data=json_data_restaurant, headers=headers_place)
            # Print the response
            result_restaurant = response_restaurant.json()
            print(result_restaurant)
            # Convert JSON data to DataFrame
            df_restaurant = pd.json_normalize(result_restaurant['places'])
            # Add 'type'
            df_restaurant['type'] = 'Restaurant'
            return df_restaurant

        def tourist():
            data_tourist = {
                'textQuery': f'Tourist attraction near {destination}',
                'minRating': min_rating,
                'languageCode': 'ko',
                'locationBias': {
                    "circle": {
                        "center": circle_center,
                        "radius": circle_radius
                    }
                }
            }

            # Convert data to JSON format
            json_data_tourist = json.dumps(data_tourist)
            # Make the POST request
            response_tourist = requests.post(url, data=json_data_tourist, headers=headers_place)
            # Print the response
            result_tourist = response_tourist.json()
            print(result_tourist)
            # Convert JSON data to DataFrame
            df_tourist = pd.json_normalize(result_tourist['places'])
            # Add 'type'
            df_tourist['type'] = 'Tourist'
            return df_tourist

        df_hotel1 = hotel()
        df_restaurant1 = restaurant()
        df_tourist1 = tourist()

        # Assuming all three dataframes have similar columns
        df_place = pd.concat([df_hotel1, df_restaurant1, df_tourist1], ignore_index=True)
        df_place = df_place.sort_values(by=['userRatingCount', 'rating'], ascending=[False, False]).reset_index(
            drop=True)

        df_place_rename = df_place[
            ['type', 'displayName.text', 'formattedAddress', 'rating', 'userRatingCount', 'googleMapsUri', 'websiteUri',
             'location.latitude', 'location.longitude', 'displayName.languageCode']]
        df_place_rename = df_place_rename.rename(columns={
            'displayName.text': 'Name',
            'rating': 'Rating',
            'googleMapsUri': 'Google Maps URL',
            'websiteUri': 'Website URL',
            'userRatingCount': 'User Rating Count',
            'location.latitude': 'Latitude',
            'location.longitude': 'Longitude',
            'formattedAddress': 'Address',
            'displayName.languageCode': 'Language Code',
            'type': 'Type'
        })

        def total_map():
            type_colour = {'Hotel': 'blue', 'Restaurant': 'green', 'Tourist': 'orange'}
            type_icon = {'Hotel': 'home', 'Restaurant': 'cutlery', 'Tourist': 'star'}
            print(df_place_rename['Latitude'][0], df_place_rename['Longitude'][0])
            mymap = folium.Map(location=(df_place_rename['Latitude'][0], df_place_rename['Longitude'][0]), zoom_start=9,
                               control_scale=True)

            for i in range(len(df_place_rename)):
                icon_color = type_colour[df_place_rename['Type'][i]]
                icon_type = type_icon[df_place_rename['Type'][i]]
                icon = folium.Icon(color=icon_color, icon=icon_type)

                # Use different icons for hotels, restaurants, and tourist attractions
                folium.Marker(location=(df_place_rename['Latitude'][i], df_place_rename['Longitude'][i]), icon=icon,
                              popup="<i>{}</i>".format(df_place_rename['Name'][i])).add_to(mymap)

            folium_static(mymap)

        def database():
            st.dataframe(df_place_rename)
            total_map()

        def route():
            st.header(f'Í∏∏ Ï∞æÍ∏∞ üó∫Ô∏è')
            start = st.text_input('Ïñ¥ÎîîÏóêÏÑú Ï∂úÎ∞úÌïòÏãúÎÇòÏöî?:')
            dest = st.text_input('Ïñ¥ÎîîÎ°ú Í∞ÄÏãúÎÇòÏöî?:')
            sel = st.selectbox('Ïñ¥ÎñªÍ≤å Í∞ÄÏãúÎÇòÏöî?', ('ÎåÄÏ§ëÍµêÌÜµÏúºÎ°ú', 'Í±∏Ïñ¥ÏÑú', 'Ï∞®Î°ú'))
            if st.button('Í∏∏ Ï∞æÍ∏∞'):
                if sel == 'ÎåÄÏ§ëÍµêÌÜµÏúºÎ°ú':
                    ddf, route1, distance, duration, start_point = route_core.s_to_d(start, dest, sel)
                    m1 = route_core.draw_route_on_folium(ddf, start_point)
                    folium_static(m1)
                    st.text(f"Í±∞Î¶¨Îäî {distance}kmÏûÖÎãàÎã§.")
                    st.text(f"ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞ÑÏùÄ {duration}ÏóêÏöî!")
                else:
                    ddf, route1, distance, duration = route_core.s_to_d(start, dest, sel)
                    m1 = route1.plot_route()
                    folium_static(m1)
                    st.text(f"Í±∞Î¶¨Îäî {distance}kmÏûÖÎãàÎã§.")
                    st.text(f"ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞ÑÏùÄ {duration}ÏóêÏöî!")

        def maps():
            st.header("üåè Ïó¨Ìñâ Í∞ÄÏù¥Îìú üåè")

            places_type = st.radio('Î¨¥ÏóáÏùÑ Ï∞æÍ≥† Í≥ÑÏã†Í∞ÄÏöî?: ', ["Ìò∏ÌÖî üè®", "ÏùåÏãùÏ†ê üç¥", "Í¥ÄÍ¥ë ‚≠ê"])
            initial_location = [initial_latitude, initial_longitude]
            type_colour = {'Hotel': 'blue', 'Restaurant': 'green', 'Tourist': 'orange'}
            type_icon = {'Hotel': 'home', 'Restaurant': 'cutlery', 'Tourist': 'star'}

            st.subheader(f"{destination} Í∑ºÏ≤òÏóêÏÑú {places_type}ÏùÑ Ï∞æÏïÑÎ¥§Ïñ¥Ïöî!")
            cur_temp = get_current_temperature(initial_latitude, initial_longitude)
            st.text(f"{destination}Ïùò ÌòÑÏû¨ Í∏∞Ïò®ÏùÄ {cur_temp}¬∞C ÏóêÏöî!")
            if cur_temp > 23:
                st.text(f"Îç•ÎÑ§Ïöî! Î∞òÌåîÏùÑ Ï±ôÍ≤®Í∞ÄÏÑ∏Ïöî!")
            elif cur_temp < 16:
                st.text(f"Ï∂•ÎÑ§Ïöî! Í∏¥ÌåîÏùÑ Ï±ôÍ≤®Í∞ÄÏÑ∏Ïöî!")
            else:
                st.text(f"ÏßÄÍ∏àÏù¥ Ïó¨ÌñâÌïòÍ∏∞ Îî± Ï¢ãÏùÄ ÎÇ†Ïî®! Î∞îÎ°ú Ï∂úÎ∞úÌïòÏÑ∏Ïöî!")

            if places_type == 'Ìò∏ÌÖî üè®':
                df_place = df_hotel1
                with st.spinner("Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî..."):
                    for index, row in df_place.iterrows():
                        location = [row['location.latitude'], row['location.longitude']]
                        mymap = folium.Map(location=initial_location,
                                           zoom_start=9, control_scale=True)
                        content = (str(row['displayName.text']) + '<br>' +
                                   'Rating: ' + str(row['rating']) + '<br>' +
                                   'Address: ' + str(row['formattedAddress']) + '<br>' +
                                   'Website: ' + str(row['websiteUri'])
                                   )
                        iframe = folium.IFrame(content, width=300, height=125)
                        popup = folium.Popup(iframe, max_width=300)

                        icon_color = type_colour[row['type']]
                        icon_type = type_icon[row['type']]
                        icon = folium.Icon(color=icon_color, icon=icon_type)

                        # Use different icons for hotels, restaurants, and tourist attractions
                        folium.Marker(location=location, popup=popup, icon=icon).add_to(mymap)

                        st.write(f"## {index + 1}. {row['displayName.text']}")
                        folium_static(mymap)
                        st.write(f"ÌèâÏ†ê: {row['rating']}")
                        st.write(f"Ï£ºÏÜå: {row['formattedAddress']}")
                        st.write(f"ÏõπÏÇ¨Ïù¥Ìä∏: {row['websiteUri']}")
                        st.write(f"Ï∂îÍ∞ÄÏ†ÅÏù∏ Ï†ïÎ≥¥: {row['googleMapsUri']}\n")


            elif places_type == 'ÏùåÏãùÏ†ê üç¥':
                df_place = df_restaurant1
                with st.spinner("Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî..."):
                    for index, row in df_place.iterrows():
                        location = [row['location.latitude'], row['location.longitude']]
                        mymap = folium.Map(location=initial_location,
                                           zoom_start=9, control_scale=True)
                        content = (str(row['displayName.text']) + '<br>' +
                                   'Rating: ' + str(row['rating']) + '<br>' +
                                   'Address: ' + str(row['formattedAddress']) + '<br>' +
                                   'Website: ' + str(row['websiteUri'])
                                   )
                        iframe = folium.IFrame(content, width=300, height=125)
                        popup = folium.Popup(iframe, max_width=300)

                        icon_color = type_colour[row['type']]
                        icon_type = type_icon[row['type']]
                        icon = folium.Icon(color=icon_color, icon=icon_type)

                        # Use different icons for hotels, restaurants, and tourist attractions
                        folium.Marker(location=location, popup=popup, icon=icon).add_to(mymap)

                        st.write(f"## {index + 1}. {row['displayName.text']}")
                        folium_static(mymap)
                        st.write(f"ÌèâÏ†ê: {row['rating']}")
                        st.write(f"Ï£ºÏÜå: {row['formattedAddress']}")
                        st.write(f"ÏõπÏÇ¨Ïù¥Ìä∏: {row['websiteUri']}")
                        st.write(f"Ï∂îÍ∞ÄÏ†ÅÏù∏ Ï†ïÎ≥¥: {row['googleMapsUri']}\n")
            else:
                df_place = df_tourist1
                with st.spinner("Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî..."):
                    for index, row in df_place.iterrows():
                        location = [row['location.latitude'], row['location.longitude']]
                        mymap = folium.Map(location=initial_location,
                                           zoom_start=9, control_scale=True)
                        content = (str(row['displayName.text']) + '<br>' +
                                   'Rating: ' + str(row['rating']) + '<br>' +
                                   'Address: ' + str(row['formattedAddress']) + '<br>' +
                                   'Website: ' + str(row['websiteUri'])
                                   )
                        iframe = folium.IFrame(content, width=300, height=125)
                        popup = folium.Popup(iframe, max_width=300)

                        icon_color = type_colour[row['type']]
                        icon_type = type_icon[row['type']]
                        icon = folium.Icon(color=icon_color, icon=icon_type)

                        # Use different icons for hotels, restaurants, and tourist attractions
                        folium.Marker(location=location, popup=popup, icon=icon).add_to(mymap)

                        st.write(f"## {index + 1}. {row['displayName.text']}")
                        folium_static(mymap)
                        st.write(f"ÌèâÏ†ê: {row['rating']}")
                        st.write(f"Ï£ºÏÜå: {row['formattedAddress']}")
                        st.write(f"ÏõπÏÇ¨Ïù¥Ìä∏: {row['websiteUri']}")
                        st.write(f"Ï∂îÍ∞ÄÏ†ÅÏù∏ Ï†ïÎ≥¥: {row['googleMapsUri']}\n")

        def chatbot():
            class Message(BaseModel):
                actor: str
                payload: str

            # ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Î∞õÍ∏∞
            user = None
            try:
                user = auth.get_user_by_email(st.session_state["username"])
            except auth.UserNotFoundError:
                st.error("ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")

            uid = user.uid

            # llm = ChatOpenAI(openai_api_key=os.environ["OPENAI_API_KEY"], model_name='gpt-3.5-turbo', temperature=0)

            USER = "user"
            ASSISTANT = "ai"
            MESSAGES = "messages"

            # def initialize_session_state():
            if MESSAGES not in st.session_state:
                st.session_state[MESSAGES] = [Message(actor=ASSISTANT, payload="ÏïàÎÖïÌïòÏÑ∏Ïöî! Ïñ¥Îñ§ ÎèÑÏõÄÏù¥ ÌïÑÏöîÌïòÏã†Í∞ÄÏöî?")]

            msg: Message
            for msg in st.session_state[MESSAGES]:
                st.chat_message(msg.actor).write(msg.payload)


            # Prompt
            query: str = st.chat_input("Ïù¥Í≥≥Ïóê ÏßàÎ¨∏ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")

            # Combine info
            df_place['combined_info'] = df_place.apply(lambda
                                                           row: f"Type: {row['type']}, Name: {row['displayName.text']}. Rating: {row['rating']}. Address: {row['formattedAddress']}. Website: {row['websiteUri']}",
                                                       axis=1)
            # Load Processed Dataset
            loader = DataFrameLoader(df_place, page_content_column="combined_info")
            docs = loader.load()

            # Document splitting
            text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
            texts = text_splitter.split_documents(docs)

            # embeddings model
            # Define the path to the pre-trained model you want to use
            modelPath = "sentence-transformers/all-MiniLM-l6-v2"

            # Create a dictionary with model configuration options, specifying to use the CPU for computations
            model_kwargs = {'device': 'cpu'}

            # Create a dictionary with encoding options, specifically setting 'normalize_embeddings' to False
            encode_kwargs = {'normalize_embeddings': False}

            # Initialize an instance of HuggingFaceEmbeddings with the specified parameters
            embeddings = HuggingFaceEmbeddings(
                model_name=modelPath,  # Provide the pre-trained model's path
                model_kwargs=model_kwargs,  # Pass the model configuration options
                encode_kwargs=encode_kwargs  # Pass the encoding options
            )

            # Vector DB
            vectorstore = FAISS.from_documents(texts, embeddings)

            # template = """
            # ÎãπÏã†Ïùò ÏûÑÎ¨¥Îäî userÍ∞Ä ÏõêÌôúÌïòÍ≤å Ïó¨ÌñâÏùÑ Í≥ÑÌöçÌïòÍ≥† ÎßàÏπ† Ïàò ÏûàÎèÑÎ°ù ÎèïÎäî Í≤ÉÏûÖÎãàÎã§.
            # Î¨¥Ï°∞Í±¥ ÌïúÍµ≠Ïñ¥Î°ú ÎãµÌïòÏã≠ÏãúÏò§.
            # Îã§Ïùå contextÏôÄ chat historyÎ•º ÌÜµÌï¥ userÍ∞Ä ÏûÖÎ†•Ìïú ÎÇ¥Ïö©ÏùÑ Î∞îÌÉïÏúºÎ°ú ÏõêÌïòÎäî ÎÇ¥Ïö©ÏùÑ Ï∞æÏùÑ Ïàò ÏûàÎèÑÎ°ù ÏßÄÏõêÌïòÍ≥†, Ïó¨ÌñâÏùÑ Í≥ÑÌöçÌï† Ïàò ÏûàÎèÑÎ°ù ÏßÄÏõêÌïòÏÑ∏Ïöî.
            # ÎßåÏïΩ userÍ∞Ä ÏùºÏ†ïÏùÑ Í≥ÑÌöçÌïòÍ∏∞Î•º ÏõêÌïúÎã§Î©¥ userÏóêÍ≤å Î™á Î™ÖÍ≥º Ìï®Íªò Í∞ÄÎäîÏßÄ, ÎàÑÍµ¨ÏôÄ Í∞ÄÎäîÏßÄ, Ïñ∏Ï†ú Í∞ÄÎäîÏßÄ, Î™á Î∞ï Î™á Ïùº ÏùºÏ†ïÏù∏ÏßÄÎ•º Î¨ºÏñ¥Î≥¥Í≥† Ïù¥ÎèôÍ±∞Î¶¨Î•º Í≥†Î†§Ìïú ÏùºÏ†ïÏùÑ ÏÑ∏ÏõåÏ£ºÏÑ∏Ïöî.
            # ÎßåÏïΩ, Ïû•ÏÜåÎ•º Ï∂îÏ≤úÌï¥Ïïº ÌïúÎã§Î©¥ Ï£ºÏÜå, Ï†ÑÌôîÎ≤àÌò∏, ÏõπÏÇ¨Ïù¥Ìä∏ÏôÄ Ìï®Íªò 3Í∞ÄÏßÄÏùò Ï∂îÏ≤úÏùÑ Ï†úÍ≥µÌïòÏÑ∏Ïöî.
            # ÌèâÏ†êÍ≥º ÏÇ¨Ïö©Ïûê ÌèâÏ†ê ÏàòÎ•º Í∏∞Ï§ÄÏúºÎ°ú Ï∂îÏ≤úÏùÑ Ï†ïÎ†¨Ìï©ÎãàÎã§.
            #
            # {context}
            #
            # chat history: {history}
            #
            # input: {question}
            # Your Response:
            # """
            #
            # # prompt = PromptTemplate(
            # #     input_variables=["context", "history", "question"],
            # #     template=template,
            # # )
            #
            # prompt = ChatPromptTemplate.from_template(template)
            #
            # memory = ConversationBufferMemory(memory_key="history", input_key="question", return_messages=True)
            # qa = RetrievalQA.from_chain_type(
            #     llm=llm,
            #     chain_type='stuff',
            #     retriever=vectorstore.as_retriever(),
            #     verbose=True,
            #     chain_type_kwargs={
            #         "verbose": True,
            #         "prompt": prompt,
            #         "memory": memory}
            # )
            #
            # google_search = GoogleSerperAPIWrapper()
            # tools = [
            #     Tool(name="Intermediate Answer",
            #          func=google_search.run,
            #          description="Í≤ÄÏÉâÏù¥ ÌïÑÏöîÌï† Îïå ÏÇ¨Ïö©"),
            #
            #     Tool(name="Knowledge Base",
            #          func=qa.run,
            #          description="Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌïÑÏöîÌïú Ï†ïÎ≥¥Í∞Ä ÏûàÏùÑ Îïå ÏÇ¨Ïö©")
            # ]
            # agent = initialize_agent(tools=tools, llm=llm, agent=AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION, verbose=True)

            agent_executor, memory = chatbot_core.agent()

            data_core.main(memory)
            st.write(memory.buffer())

            if query:
                st.session_state[MESSAGES].append(Message(actor=USER, payload=str(query)))
                st.chat_message(USER).write(query)

                with st.spinner("ÏÉùÍ∞ÅÏ§ëÏù¥ÏóêÏöî..."):
                    # response: str = qa.run(query=query)
                    # response: str = agent.invoke({'input': query})['output']
                    response: str = agent_executor.invoke({'input': query})['output']
                    st.session_state[MESSAGES].append(Message(actor=ASSISTANT, payload=response))
                    st.chat_message(ASSISTANT).write(response)
            # st.write("Chatbot")

        method = st.sidebar.radio(" ", ["Í≤ÄÏÉâ üîé", "Ï±óÎ¥á ü§ñ", "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ üìë", "Í∏∏Ï∞æÍ∏∞ üó∫Ô∏è"], key="method_app")
        if method == "Í≤ÄÏÉâ üîé":
            maps()
        elif method == "Ï±óÎ¥á ü§ñ":
            chatbot()
        elif method == "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ üìë":
            database()
        else:
            route()

    js = '''
        <script>
            var body = window.parent.document.querySelector(".main");
            console.log(body);
            body.scrollTop = 0;
        </script>
        '''

    if st.button(f"ÏúÑÎ°ú Ïù¥Îèô"):
        st.components.v1.html(js)

    st.sidebar.markdown(''' 
        ## Created by: 
        Team.ÏïåÎ¶¨ÎØ∏\n
        [ÌïúÏª¥ÏïÑÏπ¥Îç∞ÎØ∏](https://hancomacademy.com/) with nvidia\n
        special thanks to Ahmad Luay Adnani
        ''')
    st.image(
        "https://camo.githubusercontent.com/6be6e494569696bede37e8b21f6ebe646fdbad1c81e39082e5136bf5a8afc067/68747470733a2f2f63617073756c652d72656e6465722e76657263656c2e6170702f6170693f747970653d776176696e6726636f6c6f723d6175746f266865696768743d3230302673656374696f6e3d68656164657226746578743d416c692d6d6526666f6e7453697a653d3930")


if __name__ == '__main__':
    main()
